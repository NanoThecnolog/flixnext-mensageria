generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model favorito {
  id         String   @id
  title      String
  subtitle   String?
  userId     String
  created_at DateTime @default(now())
  updated_at DateTime @default(now())
  tmdbid     Int
  user       user     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model subscription {
  id                  String                @id
  userId              String                @unique
  subId               Int                   @unique
  planId              String
  startedAt           DateTime              @default(now())
  status              String
  plan                plan                  @relation(fields: [planId], references: [id])
  user                user                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscriptionHistory subscriptionHistory[]

  @@index([status])
}

model user {
  id               String        @id
  name             String
  email            String        @unique
  birthday         DateTime
  password         String
  donator          Boolean       @default(false)
  avatar           String?
  created_at       DateTime      @default(now())
  updated_at       DateTime      @default(now())
  verified         Boolean       @default(false)
  resetToken       String?
  resetTokenExpire DateTime?
  news             Boolean       @default(true)
  access           Boolean       @default(false)
  cpf              String?       @unique
  phone_number     String?
  address          address?
  favorito         favorito[]
  loginHistory     loginHistory?
  subscription     subscription?
  watchLater       watchLater[]
}

model watchLater {
  id         String   @id
  title      String
  subtitle   String
  userId     String
  created_at DateTime @default(now())
  updated_at DateTime @default(now())
  tmdbid     Int
  user       user     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model address {
  id           String  @id
  street       String
  number       String
  neighborhood String
  zipcode      String
  city         String
  complement   String?
  state        String
  userId       String  @unique
  user         user    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model loginHistory {
  id         String   @id
  userId     String   @unique
  name       String
  email      String
  lastAccess DateTime @default(now())
  user       user     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model plan {
  id           String         @id
  name         String         @unique
  price        Int
  type         String
  planId       Int            @unique
  created_at   DateTime       @default(now())
  updated_at   DateTime       @default(now())
  subscription subscription[]
}

model problem {
  id          String   @id
  title       String
  description String
  tmdbId      Int      @unique
  season      Int?
  episode     Int?
  userId      String
  status      String
  created_at  DateTime @default(now())
  updated_at  DateTime @default(now())
}

model subscriptionHistory {
  id             String       @id
  subscriptionId String
  fromStatus     String
  toStatus       String
  changedAt      DateTime     @default(now())
  subscription   subscription @relation(fields: [subscriptionId], references: [id])
}

enum InvoiceStatus {
  new
  waiting
  identified
  approved
  paid
  unpaid
  refunded
  contested
  canceled
  settled
  expired
}

enum SubscriptionStatus {
  active
  inactive
  canceled
  expired
  trial
}
